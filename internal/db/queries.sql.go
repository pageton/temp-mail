// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const deleteByInboxID = `-- name: DeleteByInboxID :exec
DELETE FROM Inbox WHERE id = ?
`

func (q *Queries) DeleteByInboxID(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteByInboxID, id)
	return err
}

const deleteExpiredEntries = `-- name: DeleteExpiredEntries :exec
DELETE FROM Email WHERE expiresAt < strftime('%s', 'now') * 1000
`

func (q *Queries) DeleteExpiredEntries(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredEntries)
	return err
}

const getEmailsForAddress = `-- name: GetEmailsForAddress :many
SELECT 
  Inbox.id,
  Email.subject,
  Email.createdAt,
  Email.expiresAt,
  (SELECT address FROM EmailAddress WHERE emailId = Email.id AND type = 'from') as fromAddress,
  (SELECT GROUP_CONCAT(address, ', ') FROM EmailAddress WHERE emailId = Email.id AND type = 'to') as toAddress
FROM Email
JOIN Inbox ON Email.id = Inbox.emailId
WHERE Inbox.address = ?
ORDER BY Email.createdAt DESC
`

type GetEmailsForAddressRow struct {
	ID          string
	Subject     sql.NullString
	Createdat   sql.NullInt64
	Expiresat   sql.NullTime
	Fromaddress sql.NullString
	Toaddress   string
}

func (q *Queries) GetEmailsForAddress(ctx context.Context, address sql.NullString) ([]GetEmailsForAddressRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmailsForAddress, address)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmailsForAddressRow
	for rows.Next() {
		var i GetEmailsForAddressRow
		if err := rows.Scan(
			&i.ID,
			&i.Subject,
			&i.Createdat,
			&i.Expiresat,
			&i.Fromaddress,
			&i.Toaddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInboxByID = `-- name: GetInboxByID :one
SELECT 
  Inbox.id,
  Inbox.textContent, 
  Inbox.htmlContent, 
  Email.subject, 
  Email.expiresAt,
  Email.createdAt,
  (SELECT address FROM EmailAddress WHERE emailId = Email.id AND type = 'from') as fromAddress,
  (SELECT GROUP_CONCAT(address, ', ') FROM EmailAddress WHERE emailId = Email.id AND type = 'to') as toAddress
FROM Inbox
JOIN Email ON Inbox.emailId = Email.id
WHERE Inbox.id = ?
`

type GetInboxByIDRow struct {
	ID          string
	Textcontent sql.NullString
	Htmlcontent sql.NullString
	Subject     sql.NullString
	Expiresat   sql.NullTime
	Createdat   sql.NullInt64
	Fromaddress sql.NullString
	Toaddress   string
}

func (q *Queries) GetInboxByID(ctx context.Context, id string) (GetInboxByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getInboxByID, id)
	var i GetInboxByIDRow
	err := row.Scan(
		&i.ID,
		&i.Textcontent,
		&i.Htmlcontent,
		&i.Subject,
		&i.Expiresat,
		&i.Createdat,
		&i.Fromaddress,
		&i.Toaddress,
	)
	return i, err
}

const insertEmail = `-- name: InsertEmail :exec
INSERT INTO Email (subject, expiresAt) 
VALUES (?, ?)
`

type InsertEmailParams struct {
	Subject   sql.NullString
	Expiresat sql.NullTime
}

func (q *Queries) InsertEmail(ctx context.Context, arg InsertEmailParams) error {
	_, err := q.db.ExecContext(ctx, insertEmail, arg.Subject, arg.Expiresat)
	return err
}

const insertEmailAddress = `-- name: InsertEmailAddress :exec
INSERT INTO EmailAddress (emailId, type, address) 
VALUES (?, ?, ?)
`

type InsertEmailAddressParams struct {
	Emailid sql.NullInt64
	Type    sql.NullString
	Address sql.NullString
}

func (q *Queries) InsertEmailAddress(ctx context.Context, arg InsertEmailAddressParams) error {
	_, err := q.db.ExecContext(ctx, insertEmailAddress, arg.Emailid, arg.Type, arg.Address)
	return err
}

const insertInbox = `-- name: InsertInbox :exec
INSERT INTO Inbox (id, emailId, address, textContent, htmlContent) 
VALUES (?, ?, ?, ?, ?)
`

type InsertInboxParams struct {
	ID          string
	Emailid     sql.NullInt64
	Address     sql.NullString
	Textcontent sql.NullString
	Htmlcontent sql.NullString
}

func (q *Queries) InsertInbox(ctx context.Context, arg InsertInboxParams) error {
	_, err := q.db.ExecContext(ctx, insertInbox,
		arg.ID,
		arg.Emailid,
		arg.Address,
		arg.Textcontent,
		arg.Htmlcontent,
	)
	return err
}
